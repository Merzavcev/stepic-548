### Виды межпроцессного взаимодействия в Linux

1. Файлы. Самый очевидный способ.
2. Сигналы. Каждое приложение имеет определенный набор сигналов, обработчики для некоторых из них могут быть переопределены.
3. Очереди сообщений. Разбираться не будут, см. man mq_overview.
4. Каналы (pipes). Делятся на именованные и неименованные (неименованные каналы мы создаем, например, в bash при ps aux | grep '').
5. Разделяемая память. Какая-то область памяти вне адресного пространства обоих взаимодействующих процессов отображается в адресное пространство каждого из них. Очень быстрый.
6. Сокеты.
7. POSIX-семафоры.
8. RPC (remote procedure call; man rpc).

### Каналы

Исторически первыми были неименованные каналы. Недостаток: в неродственных процессах их использование невозможно, так как в файловой системе имени у канала нет и можно лишь передавать его дескриптор от родителя потомкам.
Мы рассмотрим вначале неименованные каналы. Фактически при создании канала в ядре создастся буфер, который изображает поток байт. У него есть два дескриптора, один для записи и один для чтения. Теперь мы можем создать потомка, который тоже будет иметь к этим файловым дескрипторам. Теперь в родителе мы можем закрыть дескриптор для чтения, а в потомке - для записи. 
Каналы являются односторонним видом взаимодействия, если нам нужна двусторонняя коммуникация, то и родитель, и потомок должны будут использовать 2 канала.
Создаются неименованные каналы с помощью функции **pipe(2)**. Она заполнит переданный ей массив из двух дескрипторов (первый для записи, второй для чтения). Пример использования есть на man-странице:
```c
       #include <sys/types.h>
       #include <sys/wait.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <string.h>

       int
       main(int argc, char *argv[])
       {
	   int pipefd[2];
	   pid_t cpid;
	   char buf;

	   if (argc != 2) {
	       fprintf(stderr, "Usage: %s <string>\n", argv[0]);
	       exit(EXIT_FAILURE);
	   }

	   if (pipe(pipefd) == -1) {
	       perror("pipe");
	       exit(EXIT_FAILURE);
	   }

	   cpid = fork();
	   if (cpid == -1) {
	       perror("fork");
	       exit(EXIT_FAILURE);
	   }

	   if (cpid == 0) {    /* Child reads from pipe */
	       close(pipefd[1]);	  /* Close unused write end */

	       while (read(pipefd[0], &buf, 1) > 0)
		   write(STDOUT_FILENO, &buf, 1);

	       write(STDOUT_FILENO, "\n", 1);
	       close(pipefd[0]);
	       _exit(EXIT_SUCCESS);

	   } else {	       /* Parent writes argv[1] to pipe */
	       close(pipefd[0]);	  /* Close unused read end */
	       write(pipefd[1], argv[1], strlen(argv[1]));
	       close(pipefd[1]);	  /* Reader will see EOF */
	       wait(NULL);		  /* Wait for child */
	       exit(EXIT_SUCCESS);
	   }
       }
```
Пример использования: можно использовать канал для получения информации от какого-то консольного приложения с помощью функции **popen(2)**.
